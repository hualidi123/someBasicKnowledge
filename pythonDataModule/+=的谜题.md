# +=对于可变类型和不可变类型的效果是不一样的
## 不可变类型案例
```python
t1 = (1, 2, 3)
print(id(t1))
t2 = (4, 5, 6)
t1 += t2
print(t1, '\n', id(t1))
```
> 输出
140133155273608
(1, 2, 3, 4, 5, 6) 
 140133155855624

元组是不可变对象，对于不可变对象（str除外）+=会在内存中申请一个新的对象空间

**str 是一个例外，因为对字符串做 += 实在是太普遍了，所以 CPython 对它做了优化。为 str
初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉
及复制原有字符串到新位置这类操作。**

## 可变类型案例
```python
l1 = [1, 2, 3]
print(id(l1))
l2 = [4, 5, 6]
l1 += l2
print(l1, '\n', id(l1))
```
> 输出
140598388713480
[1, 2, 3, 4, 5, 6] 
140598388713480

可变类型的+=是直接在原有的变量上做追加。

# 两个值得思考的问题

## 多维数组问题
```python
l1 = [["_"]*3 for i in range(3)]
print(l1)
l1[1][2] = "x"
print(l1)

l2 = [["_"]*3]*3
print(l2)
l2[1][2] = "x"
print(l2)
```

> 输出
```shell
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
[['_', '_', '_'], ['_', '_', 'x'], ['_', '_', '_']]
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
[['_', '_', 'x'], ['_', '_', 'x'], ['_', '_', 'x']]
```
> 外面的列表其实包含 3 个指向同一个列表的引用。当我们不做修改
的时候，看起来都还好,一旦我们试图标记第 1 行第 2 列的元素，就立马暴露了列表内的 3
个引用指向同一个对象的事实

## =+谜题
```python
>>> t1=(1,2,[3,4])
>>> l1=[5,6]
>>> t1[2]+=l1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> t1
(1, 2, [3, 4, 5, 6])
>>> 
```
> 可以用dis库去观察下执行的流程，很有意思
1. 首先t1[2]的值会被存放到一个栈，叫做T吧
2. 执行T+=l1,这里也是可以的，因为T是一个列表
3. 接着就是把自加的T重新赋值t1[2]=T，这个是非法的显然，元组的元素是不可变的。
